cat("#### perm calculated ####", "\n")
param.array <- get_params(nroi = nroi, nperm = nperm, permarray = permarray,
grid = grid, mc.cores = mc.cores)
# Raw p-values (p.real, p.perm)
p.mat <- get.pval(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
return(list(.index = grid, pval = p.mat, vdparam = vdparam))
}
simu.test1 <- DVDtest(dg1, dg2, nperm. ,ev.grid)
DVDtest <- function(ydata1, ydata2, nperm, grid, dist.method = "wass",
mgcv.gam = TRUE, ..., exclude = NULL, permadj = FALSE, mc.cores = 1,
chunksize = 2, seeds = NULL, report.every = 10) {
argmt <- list(...)
if (!identical(sapply(ydata1, is.list), sapply(ydata2, is.list))) {
stop("The types of ydata1 and ydata2 are not same")
}
if (!is.list(ydata1[[1]])) {
ydata1$.obs=factor(ydata1$.obs)
ydata2$.obs=factor(ydata2$.obs)
ydata1 <- list(ydata1)
ydata2 <- list(ydata2)
}
if (!all(c(c(".obs", ".index", ".value") %in% sapply(ydata1, names),
c(".obs", ".index", ".value") %in% sapply(ydata2, names)))) {
stop("The names of ydata1&2 need to include .index, .obs and .value")
}
if (length(ydata1) != length(ydata2))
stop("The length of ydata1 and ydata2 are not same")
if (mgcv.gam & is.null(exclude) & !is.null(argmt[["formula"]]))
stop("The arguments related mgcv::gam are missing, such as formula and exclude")
nroi <- length(ydata1)
permat.all <- make.perms(ydata1[[1]], ydata2[[1]], nperm, grid, adj = permadj,
seeds = seeds)
cat("#### perm allocated ####", "\n")
reald <- get_realdist(ydata1 = ydata1, ydata2 = ydata2, grid = grid,
..., exclude = exclude, dist.method = dist.method, mc.cores = mc.cores)
realdists <- reald$realdists
cat("#### null calculated ####", "\n")
vdparam <- reald$vdparam
permatlist <- list()
# number of permutations per core
for (j in 1:(nperm/chunksize)) {
mm <- chunksize * (j - 1) + 1
MM <- chunksize * j
permatlist[[j]] <- permat.all[mm:MM, ]
}
perm.chunk <- function(whichmat, nregion = nroi) {
ob <- list()
for (k in 1:nroi) {
ob[[k]] <- wass.perm(ydata1[[k]], ydata2[[k]], permat = permatlist[[whichmat]],
grid = grid, dist.method = dist.method)
}
ob
}
ptemp = list()
for (j in 1:(nperm/chunksize/mc.cores)) {
if (!j%%report.every)cat("*** Perm", j*chunksize*mc.cores, "***\n")
lb <- mc.cores * (j - 1) + 1
ub <- mc.cores * j
ptemp[[j]] = mclapply(lb:ub, perm.chunk, mc.cores = mc.cores, mc.preschedule = FALSE)
# save(list=paste0('p',j), file=paste0('perms/p',j,'.Rdata'))
}
cat("*** Perm", j*chunksize*mc.cores, "***\n")
# Make a 101 x 74 x nperm. array of permdists nerrvec <- rep(0,nroi)
ndone <- nperm/chunksize/mc.cores
permarray <- array(dim = c(nperm, length(grid), nroi))
pcount <- 0
for (k in 1:ndone) {
pp <- ptemp[[k]]
for (co in 1:mc.cores) {
lob <- pcount + 1
pcount <- pcount + chunksize
for (reg in 1:nroi) {
permarray[lob:pcount, , reg] <- pp[[co]][[reg]]$permdists
# nerrvec[reg] <- nerrvec[reg] + pp[[co]][[reg]]$nerror
}
}
}
# permarray <- wass_perm(vdFun = vdFun, nperm = nperm, ydata1 = ydata1,
# ydata2 = ydata2,..., grid = grid, permat = permat.all, exclude =
# exclude, mc.cores = mc.cores, dist.method = dist.method)
cat("#### perm calculated ####", "\n")
param.array <- get_params(nroi = nroi, nperm = nperm, permarray = permarray,
grid = grid, mc.cores = mc.cores)
# Raw p-values (p.real, p.perm)
p.mat <- get.pval(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
return(list(.index = grid, pval = p.mat, vdparam = vdparam))
}
simu.test1 <- DVDtest(dg1, dg2, nperm. ,ev.grid)
dg1$.obs
gam(list(.value~s(.index)+s(.obs,bs="re"),~s(.index)),data=dg1)
gam(list(.value~s(.index)+s(.obs,bs="re"),~s(.index)),family=gaulss(),data=dg1)
wass.perm <- function(ydat1, ydat2, ..., permat, grid, exclude, dist.method) {
nperm <- nrow(permat)
permdists <- matrix(NA, nperm, length(grid))
nerror <- 0
ydat1$.obs=factor(ydat1$.obs)
ydat2$.obs=factor(ydat2$.obs)
for (i in 1:nperm) {
n1 <- length(unique(ydat1$.obs))
n2 <- length(unique(ydat2$.obs))
which1 <- permat[i, ]
argmt <- list(...)
bothdat <- rbind(ydat1, ydat2)
perm1 <- bothdat[bothdat$.obs %in% unique(bothdat$.obs)[which1],
]
perm2 <- bothdat[!bothdat$.obs %in% unique(bothdat$.obs)[which1],
]
if (is.null(argmt[["formula"]])) {
g1.p <- quiet(try(gam(data = perm1, formula = list(.value ~
s(.index) + s(.obs, bs = "re"), ~s(.index)), family = gaulss())))
g2.p <- quiet(try(gam(data = perm2, formula = list(.value ~
s(.index) + s(.obs, bs = "re"), ~s(.index)), family = gaulss())))
exclude <- "s(.obs)"
} else if (mgcv.gam) {
g1 <- quiet(gam(data = ydata1[[k]], formula = argmt[["formula"]],
family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = argmt[["formula"]],
family = gaulss()))
exclude <- "s(.obs)"
} else {
g1.p <- quiet(try(gamlss(data = perm1, ...)))
g2.p <- quiet(try(gamlss(data = perm2, ...)))
}
if (inherits(g1.p, "try-error") || inherits(g2.p, "try-error"))
nerror <- nerror + 1 else permdists[i, ] <- multiwass(g1.p, g2.p, newdata1 = data.frame(.index = grid,
.obs = perm1$.obs[1]), newdata2 = data.frame(.index = grid,
.obs = perm2$.obs[1]), dist.method = dist.method, exclude = exclude,
dt1 = perm1, dt2 = perm2)$wvec
}
# list(.index=.index, nperm=nperm, nerror=nerror, permdists=permdists)
return(list(permdists = permdists))
}
dg1$.obs
simu.test1 <- DVDtest(dg1, dg2, nperm. ,ev.grid)
dg1$.obs
get.realdist <- function(k, ydata1, ydata2, grid, ..., exclude, dist.method) {
argmt <- list(...)
ydata1[[k]]$.obs=ydata1[[k]]$.obs
ydata2[[k]]$.obs=ydata2[[k]]$.obs
if (is.null(argmt[["formula"]])) {
g1 <- quiet(gam(data = ydata1[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
exclude <- "s(.obs)"
} else if (mgcv.gam) {
g1 <- quiet(gam(data = ydata1[[k]], formula = argmt[["formula"]],
family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = argmt[["formula"]],
family = gaulss()))
exclude <- "s(.obs)"
} else {
g1 <- quiet(gamlss(data = ydata1[[k]], ...))
g2 <- quiet(gamlss(data = ydata2[[k]], ...))
}
rlist <- multiwass(g1, g2, newdata1 = data.frame(.index = grid, .obs = ydata1[[k]]$.obs[1]),
newdata2 = data.frame(.index = grid, .obs = ydata2[[k]]$.obs[1]),
exclude = exclude, dist.method = dist.method, dt1 = ydata1[[k]],
dt2 = ydata2[[k]])
return(list(rlist = rlist$wvec, vd.param = rlist$pred))
}
DVDtest <- function(ydata1, ydata2, nperm, grid, dist.method = "wass",
mgcv.gam = TRUE, ..., exclude = NULL, permadj = FALSE, mc.cores = 1,
chunksize = 2, seeds = NULL, report.every = 10) {
argmt <- list(...)
if (!identical(sapply(ydata1, is.list), sapply(ydata2, is.list))) {
stop("The types of ydata1 and ydata2 are not same")
}
if (!is.list(ydata1[[1]])) {
ydata1 <- list(ydata1)
ydata2 <- list(ydata2)
}
if (!all(c(c(".obs", ".index", ".value") %in% sapply(ydata1, names),
c(".obs", ".index", ".value") %in% sapply(ydata2, names)))) {
stop("The names of ydata1&2 need to include .index, .obs and .value")
}
if (length(ydata1) != length(ydata2))
stop("The length of ydata1 and ydata2 are not same")
if (mgcv.gam & is.null(exclude) & !is.null(argmt[["formula"]]))
stop("The arguments related mgcv::gam are missing, such as formula and exclude")
nroi <- length(ydata1)
permat.all <- make.perms(ydata1[[1]], ydata2[[1]], nperm, grid, adj = permadj,
seeds = seeds)
cat("#### perm allocated ####", "\n")
reald <- get_realdist(ydata1 = ydata1, ydata2 = ydata2, grid = grid,
..., exclude = exclude, dist.method = dist.method, mc.cores = mc.cores)
realdists <- reald$realdists
cat("#### null calculated ####", "\n")
vdparam <- reald$vdparam
permatlist <- list()
# number of permutations per core
for (j in 1:(nperm/chunksize)) {
mm <- chunksize * (j - 1) + 1
MM <- chunksize * j
permatlist[[j]] <- permat.all[mm:MM, ]
}
perm.chunk <- function(whichmat, nregion = nroi) {
ob <- list()
for (k in 1:nroi) {
ob[[k]] <- wass.perm(ydata1[[k]], ydata2[[k]], permat = permatlist[[whichmat]],
grid = grid, dist.method = dist.method)
}
ob
}
ptemp = list()
for (j in 1:(nperm/chunksize/mc.cores)) {
if (!j%%report.every)cat("*** Perm", j*chunksize*mc.cores, "***\n")
lb <- mc.cores * (j - 1) + 1
ub <- mc.cores * j
ptemp[[j]] = mclapply(lb:ub, perm.chunk, mc.cores = mc.cores, mc.preschedule = FALSE)
# save(list=paste0('p',j), file=paste0('perms/p',j,'.Rdata'))
}
cat("*** Perm", j*chunksize*mc.cores, "***\n")
# Make a 101 x 74 x nperm. array of permdists nerrvec <- rep(0,nroi)
ndone <- nperm/chunksize/mc.cores
permarray <- array(dim = c(nperm, length(grid), nroi))
pcount <- 0
for (k in 1:ndone) {
pp <- ptemp[[k]]
for (co in 1:mc.cores) {
lob <- pcount + 1
pcount <- pcount + chunksize
for (reg in 1:nroi) {
permarray[lob:pcount, , reg] <- pp[[co]][[reg]]$permdists
# nerrvec[reg] <- nerrvec[reg] + pp[[co]][[reg]]$nerror
}
}
}
# permarray <- wass_perm(vdFun = vdFun, nperm = nperm, ydata1 = ydata1,
# ydata2 = ydata2,..., grid = grid, permat = permat.all, exclude =
# exclude, mc.cores = mc.cores, dist.method = dist.method)
cat("#### perm calculated ####", "\n")
param.array <- get_params(nroi = nroi, nperm = nperm, permarray = permarray,
grid = grid, mc.cores = mc.cores)
# Raw p-values (p.real, p.perm)
p.mat <- get.pval(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
return(list(.index = grid, pval = p.mat, vdparam = vdparam))
}
simu.test1 <- DVDtest(dg1, dg2, nperm. ,ev.grid)
get.realdist <- function(k, ydata1, ydata2, grid, ..., exclude, dist.method) {
argmt <- list(...)
ydata1[[k]]$.obs=ydata1[[k]]$.obs
ydata2[[k]]$.obs=ydata2[[k]]$.obs
if (is.null(argmt[["formula"]])) {
g1 <- quiet(gam(data = ydata1[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
exclude <- "s(.obs)"
} else if (mgcv.gam) {
g1 <- quiet(gam(data = ydata1[[k]], formula = argmt[["formula"]],
family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = argmt[["formula"]],
family = gaulss()))
exclude <- "s(.obs)"
} else {
g1 <- quiet(gamlss(data = ydata1[[k]], ...))
g2 <- quiet(gamlss(data = ydata2[[k]], ...))
}
rlist <- multiwass(g1, g2, newdata1 = data.frame(.index = grid, .obs = ydata1[[k]]$.obs[1]),
newdata2 = data.frame(.index = grid, .obs = ydata2[[k]]$.obs[1]),
exclude = exclude, dist.method = dist.method, dt1 = ydata1[[k]],
dt2 = ydata2[[k]])
return(list(rlist = rlist$wvec, vd.param = rlist$pred))
}
simu.test1 <- DVDtest(dg1, dg2, nperm. ,ev.grid)
get.realdist <- function(k, ydata1, ydata2, grid, ..., exclude, dist.method) {
argmt <- list(...)
if (is.null(argmt[["formula"]])) {
g1 <- quiet(gam(data = ydata1[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
exclude <- "s(.obs)"
} else if (mgcv.gam) {
g1 <- quiet(gam(data = ydata1[[k]], formula = argmt[["formula"]],
family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = argmt[["formula"]],
family = gaulss()))
exclude <- "s(.obs)"
} else {
g1 <- quiet(gamlss(data = ydata1[[k]], ...))
g2 <- quiet(gamlss(data = ydata2[[k]], ...))
}
rlist <- multiwass(g1, g2, newdata1 = data.frame(.index = grid, .obs = ydata1[[k]]$.obs[1]),
newdata2 = data.frame(.index = grid, .obs = ydata2[[k]]$.obs[1]),
exclude = exclude, dist.method = dist.method, dt1 = ydata1[[k]],
dt2 = ydata2[[k]])
return(list(rlist = rlist$wvec, vd.param = rlist$pred))
}
formatR::tidy_app()
get.realdist <- function(k, ydata1, ydata2, grid, ..., exclude, dist.method) {
argmt <- list(...)
if (is.null(argmt[["formula"]])) {
g1 <- quiet(gam(data = ydata1[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = list(.value ~ s(.index) +
s(.obs, bs = "re"), ~s(.index)), family = gaulss()))
exclude <- "s(.obs)"
} else if (mgcv.gam) {
g1 <- quiet(gam(data = ydata1[[k]], formula = argmt[["formula"]],
family = gaulss()))
g2 <- quiet(gam(data = ydata2[[k]], formula = argmt[["formula"]],
family = gaulss()))
exclude <- "s(.obs)"
} else {
g1 <- quiet(gamlss(data = ydata1[[k]], ...))
g2 <- quiet(gamlss(data = ydata2[[k]], ...))
}
rlist <- multiwass(g1, g2, newdata1 = data.frame(.index = grid, .obs = ydata1[[k]]$.obs[1]),
newdata2 = data.frame(.index = grid, .obs = ydata2[[k]]$.obs[1]),
exclude = exclude, dist.method = dist.method, dt1 = ydata1[[k]],
dt2 = ydata2[[k]])
return(list(rlist = rlist$wvec, vd.param = rlist$pred))
}
formatR::tidy_app()
DVDtest <- function(ydata1, ydata2, nperm, grid, dist.method = "wass",
mgcv.gam = TRUE, ..., exclude = NULL, permadj = FALSE, mc.cores = 1,
chunksize = 2, seeds = NULL, report.every = 10, stepdown = FALSE) {
argmt <- list(...)
if (!identical(sapply(ydata1, is.list), sapply(ydata2, is.list))) {
stop("The types of ydata1 and ydata2 are not same")
}
if (!is.list(ydata1[[1]])) {
ydata1 <- list(ydata1)
ydata2 <- list(ydata2)
}
if (!all(c(c(".obs", ".index", ".value") %in% sapply(ydata1, names),
c(".obs", ".index", ".value") %in% sapply(ydata2, names)))) {
stop("The names of ydata1&2 need to include .index, .obs and .value")
}
if (length(ydata1) != length(ydata2))
stop("The length of ydata1 and ydata2 are not same")
if (mgcv.gam & is.null(exclude) & !is.null(argmt[["formula"]]))
stop("The arguments related mgcv::gam are missing, such as formula and exclude")
nroi <- length(ydata1)
for (k in 1:nroi) {
ydata1[[k]]$.obs <- factor(ydata1[[k]]$.obs)
ydata2[[k]]$.obs <- factor(ydata2[[k]]$.obs)
}
permat.all <- make.perms(ydata1[[1]], ydata2[[1]], nperm, grid, adj = permadj,
seeds = seeds)
cat("#### perm allocated ####", "\n")
reald <- get_realdist(ydata1 = ydata1, ydata2 = ydata2, grid = grid,
..., exclude = exclude, dist.method = dist.method, mc.cores = mc.cores)
realdists <- reald$realdists
cat("#### null calculated ####", "\n")
vdparam <- reald$vdparam
permatlist <- list()
# number of permutations per core
for (j in 1:(nperm/chunksize)) {
mm <- chunksize * (j - 1) + 1
MM <- chunksize * j
permatlist[[j]] <- permat.all[mm:MM, ]
}
perm.chunk <- function(whichmat, nregion = nroi) {
ob <- list()
for (k in 1:nroi) {
ob[[k]] <- wass.perm(ydata1[[k]], ydata2[[k]], permat = permatlist[[whichmat]],
grid = grid, dist.method = dist.method)
}
ob
}
ptemp = list()
for (j in 1:(nperm/chunksize/mc.cores)) {
if (!j%%report.every)cat("*** Perm", j*chunksize*mc.cores, "***\n")
lb <- mc.cores * (j - 1) + 1
ub <- mc.cores * j
ptemp[[j]] = mclapply(lb:ub, perm.chunk, mc.cores = mc.cores, mc.preschedule = FALSE)
# save(list=paste0('p',j), file=paste0('perms/p',j,'.Rdata'))
}
cat("*** Perm", j*chunksize*mc.cores, "***\n")
# Make a 101 x 74 x nperm. array of permdists nerrvec <- rep(0,nroi)
ndone <- nperm/chunksize/mc.cores
permarray <- array(dim = c(nperm, length(grid), nroi))
pcount <- 0
for (k in 1:ndone) {
pp <- ptemp[[k]]
for (co in 1:mc.cores) {
lob <- pcount + 1
pcount <- pcount + chunksize
for (reg in 1:nroi) {
permarray[lob:pcount, , reg] <- pp[[co]][[reg]]$permdists
# nerrvec[reg] <- nerrvec[reg] + pp[[co]][[reg]]$nerror
}
}
}
# permarray <- wass_perm(vdFun = vdFun, nperm = nperm, ydata1 = ydata1,
# ydata2 = ydata2,..., grid = grid, permat = permat.all, exclude =
# exclude, mc.cores = mc.cores, dist.method = dist.method)
cat("#### perm calculated ####", "\n")
param.array <- get_params(nroi = nroi, nperm = nperm, permarray = permarray,
grid = grid, mc.cores = mc.cores)
# Raw p-values (p.real, p.perm)
if (!stepdown) {
p.mat <- get.pval(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
} else {
p.mat <- get.pval.sd(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
}
return(list(.index = grid, pval = p.mat, vdparam = vdparam))
}
dg1
dg1$.obs
simu.test1 <- DVDtest(dg1, dg2, nperm. ,ev.grid)
DVDtest <- function(ydata1, ydata2, nperm, grid, dist.method = "wass",
mgcv.gam = TRUE, ..., exclude = NULL, permadj = FALSE, mc.cores = 1,
chunksize = 2, seeds = NULL, report.every = 10, stepdown = FALSE) {
argmt <- list(...)
if (!identical(sapply(ydata1, is.list), sapply(ydata2, is.list))) {
stop("The types of ydata1 and ydata2 are not same")
}
if (!is.list(ydata1[[1]])) {
ydata1 <- list(ydata1)
ydata2 <- list(ydata2)
}
if (!all(c(c(".obs", ".index", ".value") %in% sapply(ydata1, names),
c(".obs", ".index", ".value") %in% sapply(ydata2, names)))) {
stop("The names of ydata1&2 need to include .index, .obs and .value")
}
if (length(ydata1) != length(ydata2))
stop("The length of ydata1 and ydata2 are not same")
if (mgcv.gam & is.null(exclude) & !is.null(argmt[["formula"]]))
stop("The arguments related mgcv::gam are missing, such as formula and exclude")
nroi <- length(ydata1)
for (k in 1:nroi) {
ydata1[[k]]$.obs <- factor(ydata1[[k]]$.obs)
ydata2[[k]]$.obs <- factor(ydata2[[k]]$.obs)
}
permat.all <- make.perms(ydata1[[1]], ydata2[[1]], nperm, grid, adj = permadj,
seeds = seeds)
cat("#### perm allocated ####", "\n")
reald <- get_realdist(ydata1 = ydata1, ydata2 = ydata2, grid = grid,
..., exclude = exclude, dist.method = dist.method, mc.cores = mc.cores)
realdists <- reald$realdists
cat("#### real dist. calculated ####", "\n")
vdparam <- reald$vdparam
permatlist <- list()
# number of permutations per core
for (j in 1:(nperm/chunksize)) {
mm <- chunksize * (j - 1) + 1
MM <- chunksize * j
permatlist[[j]] <- permat.all[mm:MM, ]
}
perm.chunk <- function(whichmat, nregion = nroi) {
ob <- list()
for (k in 1:nroi) {
ob[[k]] <- wass.perm(ydata1[[k]], ydata2[[k]], permat = permatlist[[whichmat]],
grid = grid, dist.method = dist.method)
}
ob
}
ptemp = list()
for (j in 1:(nperm/chunksize/mc.cores)) {
if (!j%%report.every)cat("*** Perm", j*chunksize*mc.cores, "***\n")
lb <- mc.cores * (j - 1) + 1
ub <- mc.cores * j
ptemp[[j]] = mclapply(lb:ub, perm.chunk, mc.cores = mc.cores, mc.preschedule = FALSE)
# save(list=paste0('p',j), file=paste0('perms/p',j,'.Rdata'))
}
cat("*** Perm", j*chunksize*mc.cores, "***\n")
# Make a 101 x 74 x nperm. array of permdists nerrvec <- rep(0,nroi)
ndone <- nperm/chunksize/mc.cores
permarray <- array(dim = c(nperm, length(grid), nroi))
pcount <- 0
for (k in 1:ndone) {
pp <- ptemp[[k]]
for (co in 1:mc.cores) {
lob <- pcount + 1
pcount <- pcount + chunksize
for (reg in 1:nroi) {
permarray[lob:pcount, , reg] <- pp[[co]][[reg]]$permdists
# nerrvec[reg] <- nerrvec[reg] + pp[[co]][[reg]]$nerror
}
}
}
# permarray <- wass_perm(vdFun = vdFun, nperm = nperm, ydata1 = ydata1,
# ydata2 = ydata2,..., grid = grid, permat = permat.all, exclude =
# exclude, mc.cores = mc.cores, dist.method = dist.method)
cat("#### perm dist. calculated ####", "\n")
param.array <- get_params(nroi = nroi, nperm = nperm, permarray = permarray,
grid = grid, mc.cores = mc.cores)
# Raw p-values (p.real, p.perm)
if (!stepdown) {
p.mat <- get.pval(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
} else {
p.mat <- get.pval.sd(permarray = permarray, param.array = param.array,
realdists = realdists, nroi = nroi, grid = grid, nperm = nperm)
}
return(list(.index = grid, pval = p.mat, vdparam = vdparam))
}
simu.test2 <- DVDtest(dg1, dg2, nperm.,ev.grid, formula = .value ~ pb(.index),
sigma.formula = ~pb(.index), random = ~1|.obs, family = NO, mgcv.gam=FALSE)
gamlss(formula = .value ~ pb(.index),
sigma.formula = ~pb(.index), random = ~1|.obs, family = NO, data=dg1)
tst<-gamlss(formula = .value ~ pb(.index),
sigma.formula = ~pb(.index), random = ~1|.obs, family = NO, data=dg1)
tst
summary(tst)
tst$family
library(gamlss)
tst<-gamlss(formula = .value ~ pb(.index),sigma.formula = ~pb(.index), random = ~1|.obs, family = NO, data=dg1)
tst
tst<-gamlss(formula = .value ~ pb(.index),sigma.formula = ~pb(.index), random = ~1|.obs, family = NO, data=dg1)
tst
DVDtest(dg1, dg2, nperm.,ev.grid, formula = .value ~ pb(.index), sigma.formula = ~pb(.index), nu.formula= ~pb(.index), seeds=123, random = ~1|.obs, family = GG, mgcv.gam = FALSE))
DVDtest(dg1, dg2, nperm.,ev.grid, formula = .value ~ pb(.index), sigma.formula = ~pb(.index), nu.formula= ~pb(.index), seeds=123, random = ~1|.obs, family = GG, mgcv.gam = FALSE)
